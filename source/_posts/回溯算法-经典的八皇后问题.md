---
title: '[回溯算法]经典的八皇后问题'
date: 2019-04-11 20:46:28
tags:
- 数据结构与算法
- 回溯法
---

## [回溯算法]以八皇后问题和括号生成问题为例

> 回溯算法的本质是一种枚举，它从解决问题的所有可能选项里系统的选出一个可执行的解决方案

#### 1. 回溯法适合解决什么问题？

回溯法非常适合解决由**多个步骤组成**的问题，并且每一个步骤有多个选项。当我们选择了其中一个选项是，就进入下一步，然后面临新的选项，重复选择，直至解决问题。一般采用递归。例如八皇后问题和LeetCode括号生成

#### 2. 回溯法的关键步骤

- 选择：构建算法的第一步，第一步选择往往由有限个选择开始，一般由多个if或for循环实现
- 条件：对于每一步选择，必须满足特定条件，否则回溯
- 结束：当满足特定条件时，得出一个正确结果，把解存储下来或者打印出来。有时还需要构建一个数据结构，把解存储起来，这个数据结构必须是全局的，作为参数之一传递给递归函数

**注意：上述三个步骤在实现时，有时实现顺序与上述不同，有时选择和条件会混在一起**

<!--more-->

#### 3.实例分析1：八皇问题 

##### 思路：

从第一行摆棋子，然后摆第二行....直到最后一行，每摆一个棋子检查是否冲突，冲突则回溯

##### 三个步骤：

- 选择：第一步可选的位置有八个,如*号所示位置，对于每一个选择，都会面临着多个后续选择

```java
/*
    1 2 3 4 5 6 7 8
1 |*|*|*|*|*|*|*|*|
2 | | | | | | | | |
3 | | | | | | | | |
4 | | | | | | | | |
5 | | | | | | | | |
6 | | | | | | | | |
7 | | | | | | | | |
8 | | | | | | | | |
*/
```

- 条件：如果接下来要放的棋子，与之前所放的棋子发生冲突，则回溯
- 结束：如果递归执行到了第8次，即每一行都放上了棋子（不发生冲突）则得到一个正确结果

##### 代码分析

```java
public class EightQueen {
	private static int res = 0;
	private static int[][] array = new int[8][8];
	public static void findNext(int row) {
		if(row >= 8) { //结束
			printBoard();
			res++;
			return;
		}
		for(int i=0;i<8;i++) { //选择
			if(check(row,i)) { //条件：冲突检查
				array[row][i]= 1; 
				findNext(row+1); //满足条件，进行递归
				array[row][i]= 0; //避免回溯时的脏数据
			}
		}
	}
	/**
	 * 冲突检查
	 * @param row 行
	 * @param col 列
	 * @return
	 */
	public static boolean check(int row,int col) {
		for(int i=0;i<row;i++) {
			if(array[i][col] == 1) {
				return false;
			}
		}
		for(int i=row-1,j=col+1;i>=0 && j<8;i--,j++) {
			if(array[i][j] == 1) {
				return false;
			}
		}
		for(int i=row-1,j=col-1;i>=0 && j>=0;i--,j--) {
			if(array[i][j] == 1) {
				return false;
			}
		}
		
		return true;
	}
	/**
	 * 打印棋盘
	 */
	public static void printBoard() {
		for(int i = 0;i<8;i++) {
			for(int j = 0;j<8;j++) {
				System.out.print(array[i][j] + " " );
			}
			System.out.println();
		}
		System.out.println("-----------------");
	}
	public static void main(String[] args) {
		findNext(0);
		System.out.println(res);
	}
	
} 
```

#### 4.实例分析1：括号生成

给出 *n* 代表生成括号的对数，请你写出一个函数，使其能够生成所有可能的并且**有效的**括号组合。

例如，给出 *n* = 3，生成结果为：

```
[
  "((()))",
  "(()())",
  "(())()",
  "()(())",
  "()()()"
]
```

##### 思路：

手里有n个  ‘ ( ' 和 n个 ' ) ' 然后不断往一个空字符串后边添加括号，全部括号都添加完毕，则得到正确结果

##### 三个步骤：

- 选择：左括号没有全部添加，则继续添加
- 条件：只有当剩余的右括号比左括号多时，才能添加右括号，否则括号不匹配
- 结束：所有括号添加完毕，得到一个正确结果

##### 代码分析：

```java
class Solution {
    public List<String> generateParenthesis(int n) {
        List<String> res = new ArrayList<String>(); //全局变量用于存储结果
        pailie("",res,n,n);//存储结果的全局变量作为参数，传入递归！
        return res;
    }
    public void pailie(String subString,List<String> res,int leftnum,int rightnum){
        
        if(leftnum == 0 && rightnum == 0){ //结束
            res.add(subString);
        }
        if(leftnum > 0){ //选择和条件
            pailie(subString + "(",res,leftnum-1,rightnum);//递归
        }
        //只有当剩余的右括号比左括号多时才能添加右括号
        if(rightnum > leftnum){ //选择和条件
            pailie(subString + ")",res,leftnum,rightnum-1);//递归
        }
    }
}
```

