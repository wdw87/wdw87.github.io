---
title: 二分查找--最大化最小值
date: 2019-10-20 21:00:05
tags:
- 算法
- 二分查找
---

# 二分查找--最大化最小值

## 题目描述--LeetCode5111

你有一大块巧克力，它由一些甜度不完全相同的小块组成。我们用数组 sweetness 来表示每一小块的甜度。

你打算和 K 名朋友一起分享这块巧克力，所以你需要将切割 K 次才能得到 K+1 块，每一块都由一些 连续 的小块组成。

为了表现出你的慷慨，你将会吃掉 总甜度最小 的一块，并将其余几块分给你的朋友们。

请找出一个最佳的切割策略，使得你所分得的巧克力 总甜度最大，并返回这个 最大总甜度。

<!--more-->

示例 1：

输入：sweetness = [1,2,3,4,5,6,7,8,9], K = 5
输出：6
解释：你可以把巧克力分成 [1,2,3], [4,5], [6], [7], [8], [9]。
示例 2：

输入：sweetness = [5,6,7,8,9,1,2,3,4], K = 8
输出：1
解释：只有一种办法可以把巧克力分成 9 块。
示例 3：

输入：sweetness = [1,2,2,1,2,2,1,2,2], K = 2
输出：5
解释：你可以把巧克力分成 [1,2,2], [1,2,2], [1,2,2]。

> 简单地说就是把一个数组划分成连续的K+1段，使和最小的一段经可能的大，即最大化最小值

## 题目分析

在本题中，我们不知道这个最大的最小值是多少，因此可以猜测为该值为 m，然后对m进行检验，如果原数组可以顺利的按照m划分，能够分出k+1段和**大于等于**m的连续子数组，则认为m合法。

那么如何猜测这个值呢？用二分的思想：

二分查找要求被查找的序列具有单调性，数组分的次数越多，每段和就越小，就越有可能满足要求。正是基于这一**单调的线性关系**，将**最优化问题**转换为**判定问题**。

具体地说：

如果测试发现当前的值能够满足将数组切分为k+1个子数组时，则这时应将当前的值进行增加，如果测试发现当前设置的最大值不能满足刚好将数组切分成为小于K+1个子数组，则表示当前测试的值设置过大，应将测试数进行缩小。

## 解决

```java
class Solution {
    //该函数用于检验值m是否合法
    private boolean check(int[] s,int k,int m){
        int sum = 0;
        int cnt = 0;
        for(int i = 0; i < s.length; i++){
            sum += s[i];
            if(sum >= m){
                cnt ++;
                sum = 0;
            }
        }
        return cnt > k;
    }
    public int maximizeSweetness(int[] sweetness, int K) {
        int l = 0;
        int r = (int)1e9;
        int res = 0;
        // for(int i = 0; i < sweetness.length; i++){
        //     r += sweetness[i];
        // }
        while(l <= r){
            int m = l + (r - l) / 2;
            if(check(sweetness,K,m)){
                res = m;
                l = m + 1;
            }else{
                r = m - 1;
            }
        }
        return res;
    }
}
```

## 注意事项

- 该类型题目，检验方法check()依据题目不同而不同
- 二分查找的while循环为**<=**号，否则会陷入死循环

